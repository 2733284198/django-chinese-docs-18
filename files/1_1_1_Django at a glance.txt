Django at a glance

Because Django was developed in a fast-paced newsroom environment, it was designed to make common Web-development tasks fast and easy. Here＊s an informal overview of how to write a database-driven Web app with Django.

The goal of this document is to give you enough technical specifics to understand how Django works, but this isn＊t intended to be a tutorial or reference 每 but we＊ve got both! When you＊re ready to start a project, you can start with the tutorial or dive right into more detailed documentation.

Design your model

Although you can use Django without a database, it comes with an object-relational mapper in which you describe your database layout in Python code.

The data-model syntax offers many rich ways of representing your models 每 so far, it＊s been solving many years＊ worth of database-schema problems. Here＊s a quick example

(code)

Install it

Next, run the Django command-line utility to create the database tables automatically

(code)

The migrate command looks at all your available models and creates tables in your database for whichever tables don＊t already exist, as well as optionally providing much richer schema control.

Enjoy the free API

With that, you＊ve got a free, and rich, Python API to access your data. The API is created on the fly, no code generation necessary

(code)

The philosophy here is that your site is edited by a staff, or a client, or maybe just you 每 and you don＊t want to have to deal with creating backend interfaces just to manage content.

One typical workflow in creating Django apps is to create models and get the admin sites up and running as fast as possible, so your staff (or clients) can start populating data. Then, develop the way data is presented to the public.

Design your URLs

A clean, elegant URL scheme is an important detail in a high-quality Web application. Django encourages beautiful URL design and doesn＊t put any cruft in URLs, like .php or .asp.

To design URLs for an app, you create a Python module called a URLconf. A table of contents for your app, it contains a simple mapping between URL patterns and Python callback functions. URLconfs also serve to decouple URLs from Python code.

Here＊s what a URLconf might look like for the ReporterArticle example above

(code)

The code above maps URLs, as simple regular expressions, to the location of Python callback functions (※views§). The regular expressions use parenthesis to ※capture§ values from the URLs. When a user requests a page, Django runs through each pattern, in order, and stops at the first one that matches the requested URL. (If none of them matches, Django calls a special-case 404 view.) This is blazingly fast, because the regular expressions are compiled at load time.

Once one of the regexes matches, Django imports and calls the given view, which is a simple Python function. Each view gets passed a request object 每 which contains request metadata 每 and the values captured in the regex.

For example, if a user requested the URL ※articles20050539323§, Django would call the function news.views.article_detail(request, '2005', '05', '39323').

Write your views

Each view is responsible for doing one of two things Returning an HttpResponse object containing the content for the requested page, or raising an exception such as Http404. The rest is up to you.

Generally, a view retrieves data according to the parameters, loads a template and renders the template with the retrieved data. Here＊s an example view for year_archive from above

(code)

This example uses Django＊s template system, which has several powerful features but strives to stay simple enough for non-programmers to use.

Design your templates

The code above loads the newsyear_archive.html template.

Django has a template search path, which allows you to minimize redundancy among templates. In your Django settings, you specify a list of directories to check for templates with DIRS. If a template doesn＊t exist in the first directory, it checks the second, and so on.

Let＊s say the newsyear_archive.html template was found. Here＊s what that might look like

(code)

Variables are surrounded by double-curly braces. {{ article.headline }} means ※Output the value of the article＊s headline attribute.§ But dots aren＊t used only for attribute lookup. They also can do dictionary-key lookup, index lookup and function calls.

Note {{ article.pub_datedateF j, Y }} uses a Unix-style ※pipe§ (the ※§ character). This is called a template filter, and it＊s a way to filter the value of a variable. In this case, the date filter formats a Python datetime object in the given format (as found in PHP＊s date function).

You can chain together as many filters as you＊d like. You can write custom template filters. You can write custom template tags, which run custom Python code behind the scenes.

Finally, Django uses the concept of ※template inheritance§. That＊s what the {% extends base.html %} does. It means ※First load the template called ＆base＊, which has defined a bunch of blocks, and fill the blocks with the following blocks.§ In short, that lets you dramatically cut down on redundancy in templates each template has to define only what＊s unique to that template.

Here＊s what the ※base.html§ template, including the use of static files, might look like

(code)

Simplistically, it defines the look-and-feel of the site (with the site＊s logo), and provides ※holes§ for child templates to fill. This makes a site redesign as easy as changing a single file 每 the base template.

It also lets you create multiple versions of a site, with different base templates, while reusing child templates. Django＊s creators have used this technique to create strikingly different mobile versions of sites 每 simply by creating a new base template.

Note that you don＊t have to use Django＊s template system if you prefer another system. While Django＊s template system is particularly well-integrated with Django＊s model layer, nothing forces you to use it. For that matter, you don＊t have to use Django＊s database API, either. You can use another database abstraction layer, you can read XML files, you can read files off disk, or anything you want. Each piece of Django 每 models, views, templates 每 is decoupled from the next.

This is just the surface

This has been only a quick overview of Django＊s functionality. Some more useful features

A caching framework that integrates with memcached or other backends.
A syndication framework that makes creating RSS and Atom feeds as easy as writing a small Python class.
More sexy automatically-generated admin features 每 this overview barely scratched the surface.
The next obvious steps are for you to download Django, read the tutorial and join the community. Thanks for your interest!